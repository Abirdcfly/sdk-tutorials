(window.webpackJsonp=window.webpackJsonp||[]).push([[89],{703:function(e,t,s){"use strict";s.r(t);var o=s(1),n=Object(o.a)({},(function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h1",{attrs:{id:"testing"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#testing"}},[e._v("#")]),e._v(" Testing")]),e._v(" "),s("HighlightBox",{attrs:{type:"prerequisite"}},[s("p",[e._v("It is recommended to first read the following sections to better understand testing:")]),e._v(" "),s("ul",[s("li",[s("RouterLink",{attrs:{to:"/academy/2-cosmos-concepts/3-transactions.html"}},[e._v("Transactions")])],1),e._v(" "),s("li",[s("RouterLink",{attrs:{to:"/academy/2-cosmos-concepts/4-messages.html"}},[e._v("Messages")])],1),e._v(" "),s("li",[s("RouterLink",{attrs:{to:"/academy/2-cosmos-concepts/5-modules.html"}},[e._v("Modules")])],1),e._v(" "),s("li",[s("RouterLink",{attrs:{to:"/academy/2-cosmos-concepts/8-base-app.html"}},[e._v("BaseApp")])],1)])]),e._v(" "),s("HighlightBox",{attrs:{type:"learning"}},[s("p",[e._v("Testing is the general umbrella that describes all that revolves around making sure that any code created does what it is expected to do.")])]),e._v(" "),s("p",[e._v("Testing is an integral part of software development in general. Done well, it helps teams catch bugs earlier, and thus, repairing problems becomes cheaper. In the context of blockchains, which can lock large amounts of value and where "),s("RouterLink",{attrs:{to:"/academy/2-cosmos-concepts/12-migrations.html"}},[e._v("migrations")]),e._v(" are not simply one redeploy away from a fix, bugs can be catastrophic.")],1),e._v(" "),s("p",[e._v("The Cosmos SDK implements its own testing vision for its modules, and it would be good if your project followed the same patterns. Following the same patterns will help everyone in the ecosystem "),s("em",[e._v("speak the same language")]),e._v(". Speaking the same language is also beneficial when you open the code for a bug bounty. Indeed, readable tests increase the trust that casual observers have in your code overall and, by extension, your project, and allow interested bounty hunters to be "),s("em",[e._v("onboarded")]),e._v(" faster.")]),e._v(" "),s("h2",{attrs:{id:"testing-pyramid"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#testing-pyramid"}},[e._v("#")]),e._v(" Testing pyramid")]),e._v(" "),s("p",[e._v("After some "),s("a",{attrs:{href:"https://docs.cosmos.network/main/architecture/adr-059-test-scopes.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("reflection"),s("OutboundLink")],1),e._v(", Cosmos divides tests into four broad categories of somewhat increasing scope:")]),e._v(" "),s("ul",[s("li",[s("a",{attrs:{href:"https://docs.cosmos.network/main/building-modules/testing#unit-tests",target:"_blank",rel:"noopener noreferrer"}},[e._v("Unit tests"),s("OutboundLink")],1)]),e._v(" "),s("li",[s("a",{attrs:{href:"https://docs.cosmos.network/main/building-modules/testing#integration-tests",target:"_blank",rel:"noopener noreferrer"}},[e._v("Integration tests"),s("OutboundLink")],1)]),e._v(" "),s("li",[s("a",{attrs:{href:"https://docs.cosmos.network/main/building-modules/testing#simulations",target:"_blank",rel:"noopener noreferrer"}},[e._v("Simulation tests"),s("OutboundLink")],1)]),e._v(" "),s("li",[s("a",{attrs:{href:"https://docs.cosmos.network/main/building-modules/testing#end-to-end-tests",target:"_blank",rel:"noopener noreferrer"}},[e._v("End-to-end tests (E2E)"),s("OutboundLink")],1)])]),e._v(" "),s("h3",{attrs:{id:"unit-tests"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#unit-tests"}},[e._v("#")]),e._v(" Unit tests")]),e._v(" "),s("p",[e._v('Unit tests are your classic "smallest tests possible", and focus on a single module at a time. If a tested call needs something from another module, like a keeper, then:')]),e._v(" "),s("ul",[s("li",[e._v("This dependency should be "),s("a",{attrs:{href:"https://devopedia.org/mock-testing",target:"_blank",rel:"noopener noreferrer"}},[e._v("mocked"),s("OutboundLink")],1),e._v(", including mocked responses when applicable.")]),e._v(" "),s("li",[e._v("The mock should confirm that the dependency was called as expected.")]),e._v(" "),s("li",[e._v("If applicable, the test should confirm that a mocked response was handled as expected by the module under test.")])]),e._v(" "),s("p",[e._v("To be considered well-tested, your unit tests should cover "),s("strong",[e._v("all")]),e._v(" your module's functions.")]),e._v(" "),s("p",[e._v("As an example, imagine that your module moves tokens on behalf of your users. Your module, therefore, has a dependency on the bank keeper. As part of a unit test setup, you create a mocked bank keeper and use it. After the test action, at verification time, your unit test confirms that your module called the expected functions of the bank keeper within the expected parameters. Your unit test does "),s("strong",[e._v("not")]),e._v(" test whether bank balances have changed because, remember, your module does not have a real bank keeper.")]),e._v(" "),s("h3",{attrs:{id:"integration-tests"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#integration-tests"}},[e._v("#")]),e._v(" Integration tests")]),e._v(" "),s("p",[e._v("Integration tests are one step wider in scope. They are still focused on your module but, instead of mocking the dependencies, now your test provisions a "),s("strong",[e._v("minimum-viable application")]),e._v(" that includes fully-fledged dependencies, including – crucially – those your own module needs.")]),e._v(" "),s("HighlightBox",{attrs:{type:"info"}},[s("p",[e._v("A minimum-viable application contains your module and all its dependencies, as well as their dependencies, but nothing more.")])]),e._v(" "),s("p",[e._v("In a well-designed testing environment, providing such fully-fledged dependencies should not be a concern of your module's tests. All the more so if your dependencies have dependencies of their own. You want to minimize such deep correlations between modules, even in regard to their tests.")]),e._v(" "),s("p",[e._v("This is why, to minimize correlations, from version 0.47 of the Cosmos SDK onward each module exposes functions to provide a minimum viable module. This way, your module only knows how to instantiate itself given fully-fledged dependencies, the "),s("em",[e._v("inputs")]),e._v(". An added benefit is that your module exposes explicitly the inputs it needs to instantiate.")]),e._v(" "),s("p",[e._v("Your integration tests start by creating an app that instantiates the list of explicitly defined inputs required. For instance, when creating a minimum-viable app to integration-test the bank module, no slashing module is provisioned, as slashing is a side concern instead of a dependency. Of course, each module requires a different minimum-viable app. To facilitate the creation of such an app and therefore, of integration tests, the Cosmos SDK team has also developed an in-house dependency injection.")]),e._v(" "),s("p",[e._v("To fit in the context of Go testing, modules provide testing suites that encapsulate the test instantiations.")]),e._v(" "),s("HighlightBox",{attrs:{type:"note"}},[s("p",[e._v('In Cosmos SDK version 0.46 and earlier, what are called "integration tests" are really full tests, where a full application is being instantiated. The reason behind this is that in these versions the coding effort to create a minimum-viable app was not commensurate with the benefit it provided compared to a full app.')])]),e._v(" "),s("h3",{attrs:{id:"simulation-tests"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#simulation-tests"}},[e._v("#")]),e._v(" Simulation tests")]),e._v(" "),s("p",[e._v("The purpose of simulation tests is to introduce some random effects into the parameters passed.")]),e._v(" "),s("p",[e._v("Simulation tests are similar in scope to integration tests, where they reuse your module's minimum-viable application. This scope also only starts to make sense from Cosmos SDK 0.47, where the application dependencies are disentangled.")]),e._v(" "),s("h3",{attrs:{id:"end-to-end-tests"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#end-to-end-tests"}},[e._v("#")]),e._v(" End-to-end tests")]),e._v(" "),s("p",[e._v("End-to-end (E2E) tests are at the top of the testing pyramid. Unlike integration and simulation tests, they work by testing the "),s("em",[e._v("full")]),e._v(" application, not a minimum-viable one.")]),e._v(" "),s("p",[e._v("Your E2E tests should test flows that mirror what users would experience, and therefore, should not limit themselves to minute interactions. Conceptually, they are for your whole application, and not per module.")]),e._v(" "),s("HighlightBox",{attrs:{type:"remember"}},[s("p",[e._v('As stated, if you work with Cosmos versions 0.46 or earlier, any tests that are labeled "integration tests" are actually E2E tests under the new designation from version 0.47 onward.')])]),e._v(" "),s("p",[e._v("In the context of Go, just like for integration tests, you provide testing suites that handle the instantiations. Ideally, your testing suite should be usable outside of your application so that other applications can test interactions with yours.")]),e._v(" "),s("HighlightBox",{attrs:{type:"reading"}},[s("p",[s("strong",[e._v("Further reading")])]),e._v(" "),s("ul",[s("li",[s("a",{attrs:{href:"https://docs.cosmos.network/main/architecture/adr-059-test-scopes.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("Test scopes decision report"),s("OutboundLink")],1)])])]),e._v(" "),s("HighlightBox",{attrs:{type:"synopsis"}},[s("p",[e._v("To summarize, this section has explored:")]),e._v(" "),s("ul",[s("li",[e._v("Why testing is important.")]),e._v(" "),s("li",[e._v("How the Cosmos SDK conceptually divides its tests.")]),e._v(" "),s("li",[e._v("What is the scope and what happens in each test category.")])])])],1)}),[],!1,null,null,null);t.default=n.exports}}]);